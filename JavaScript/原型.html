<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>



    <script>
        // function Po() {};
        // Po.prototype.name = "yuanxing";
        // Po.prototype.age = 18;
        // Po.prototype.run = function () {
        //     return this.name + this.age + '运行中~~~~'
        // };

        // var str = new Po();
        // console.log(str.run());

        // function All(){};

        // var a=new All();
        // console.log(a.prototype);    
        // console.log(a._proto_);
        // console.log(All.prototype)

        //使用字面量的方式创建原型
    //     function Box() {};
    //     Box.prototype = {
    //         name : 'ssss',
    //         age :18,
    //         run: function () {
    //            return this.name + this.age + '啊啊啊啊啊啊啊啊啊ffffffffffffffffffff'
    //         }

    //     }

    //     var box = new Box();
    //     document.write(box.run());

    //     Box.prototype={
    //         age:90
    //     }
    //    var box = new Box();
       
    //  /// // document.write(box.name);
    //   // document.write(box.run());
    //    document.write(box.age);


    //原型和构造函数混合

    function Box(name,age) {
        this.name=name;
        this.age=age;
        //console.log('我被初始化了');
        Box.prototype.run=function(){
           return this.name+this.age+'我的代码早已饥渴难耐~~~~~~'
        };
        //console.log('我被初始化了2次');
    };
      //这样封装到构造函数里面可以使用传参.而且不共享固定原型部分
      //但是原型被调用来2次,new一次,运行一次,浪费内存.
    var box1 =new Box('张三',28);
    console.log(box1.run());



    </script>
    <br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
    原型<br>
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</body>

</html>